//namespace PriorityQueue_우선순위큐
//{
//    // 우선순위큐

//    class PriorityQueue
//    {
//        List<int> _heap = new List<int>();

//        public void Push(int data)
//        {
//            _heap.Add(data);
//            // 일단 노드 맨 아래 추가
//            /*
//                       [32]
//                      /    \
//                   [26]    [15]
//                  /   \    /   \
//               [19]  [14] [6]  [13]
//               / \    /
//            [1][10] [new]
//            */

//            int now = _heap.Count - 1;
//            while(now > 0)
//            {
//                // 부모 구하기
//                int next = (now - 1) / 2;
//                // Count == 10
//                //  0   1   2   3   4   5   6  7   8   9
//                // [32][26][15][19][14][6][13][1][10][new]

//                /*
//                           [0]
//                          /   \
//                       [1]     [2]
//                      /   \   /   \
//                     [3] [4] [5]  [6]

//                노드 1 : 
//                (1-1) / 2 = 0

//                노드 2 :
//                (2-1) / 2 = 0

//                노드 3 :
//                (3-1) / 2 = 1

//                노드 4 :
//                (4-1) / 2 = 1

//                노드 5 : 
//                (5-1) / 2 = 2

//                노드 6 : 
//                (6-1) / 2 = 2

//                즉, 부모를 구하는 공식 = (now-1)/2
//                 */
                
//                // 지금 새로 들어온 애가 부모 노드 보다 작다면 그대로 종료
//                if (_heap[now] < _heap[next])
//                    break;

//                // 만약 새로 들어온 애가 부모 노드 보다 크다면 두 값을 교체한다
//                int temp = _heap[now];
//                _heap[now] = _heap[next];
//                _heap[next] = temp;
//                /*
//                               [32]
//                              /    \
//                           [26]    [15]
//                          /   \    /   \
//                       [19]  [new] [6]  [13]
//                       / \    /
//                    [1][10] [14]
//                */

//                // 검사 위치 이동              
//                //  0   1   2   3   4   5   6  7   8   9
//                // [32][26][15][19][new][6][13][1][10][14]
//                //                  ^                  ^
//                //                 next   <--------   now
//                now/*9*/ = next/*4*/;
//            }
//        }

//        public int Pop()
//        {
//            // 반환데이터 저장
//            int ret = _heap[0];
//            /*
//                               [32] <---------      
//                              /    \         |
//                           [26]    [15]      |
//                          /   \    /   \     |
//                       [19]  [14] [6]  [13]  |
//                       / \                   |
//                    [1] [10] ----------------- 

//            꼴지 노드를 가장 상위로 올려서 트리의 형태를 유지
//            */
//            int lastIndex = _heap.Count - 1;
//            _heap[0] = _heap[lastIndex];
//            _heap.RemoveAt(lastIndex);
//            lastIndex--;
//            /*
//                               [32]                       ---> [10]     
//                              /    \                          /    \   
//                           [26]    [15]                    [26]    [15] 
//                          /   \    /   \                   /   \    /   \
//                       [19]  [14] [6]  [13]             [19]  [14] [6]  [13]
//                       / \                              /
//                    [1]  [10]  <---                   [1]  
                
//            꼴지 노드를 최상위에 올리고 최하위 노드를 RemoveAt 으로 삭제
//            그리고, 라스트 인덱스 1 감소
            
//                                  [10]
//                                  /   \
//                                 /     \
//                                /       \
//                               /         \
//                              /           \  
//                             /             \
//                          [26] <누가더큼?> [15]      
//                         /   \            /   \     
//                       [19]  [14]       [6]  [13]  
//                       /                    
//                    [1]  
//            바로 밑 자식 노드중 더 큰쪽 으로 비교 시도 해야함
//            */
//            int now = 0;
//            while(true)
//            {
//                // 왼쪽 자식 노드 구하기
//                int left = 2 * now + 1;
//                int right = 2 * now + 1;
//                /*
//                           [0]
//                          /   \
//                       [1]     [2]
//                      /   \   /   \
//                     [3] [4] [5]  [6]

//                노드 1 : 
//                2 * 0 + 1 = 1

//                노드 2 :
//                2 * 0 + 2 = 2

//                왼쪽 자식 구하는 공식   = 2 * now + 1
//                오른쪽 자식 구하는 공식 = 2 * now + 2
//                 */

//                int next = now;
//                /*
//                               [10]<    
//                              /    \         
//                           [26]    [15]      
//                          /   \    /   \     
//                       [19]  [14] [6]  [13]  
//                       /                    
//                    [1]  
//                */

//                // 왼쪽값 부터 비교 하는데, 범위를 초과하지 않도록 조심
//                if (left <= lastIndex && _heap[next] < _heap[left])
//                    next = left;
//                /*
//                               [10]     
//                              /    \         
//                           [26]<   [15]      
//                          /   \    /   \     
//                       [19]  [14] [6]  [13]  
//                       /                    
//                    [1]  
//                */
//                if (right <= lastIndex && _heap[next] < _heap[right])
//                    next = right;
//                /*
//                               [10]     
//                              /    \         
//                얘가더큼--->[26]<   [15]      
//                          /   \    /   \     
//                       [19]  [14] [6]  [13]  
//                       /                    
//                    [1]  
//                */

//                // 만약, 왼쪽 오른쪽 모두 now 보다 작다면 종료
//                if (next == now)
//                    break;
//                /*
//                위의 경우가 없을것 같지만 있음

//                        [7]
//                       /   \
//                    [5]     [6]

//                루트(7) 삭제 -> 마지막 노드(6)를 루트로 올림

//                        [6]
//                       /   
//                    [5]     
//                */

//                // 이제 두값을 교체
//                int temp = _heap[now];
//                _heap[now] = _heap[next];
//                _heap[next] = temp;
//                /*
//                         --->  [10]                            [26]     
//                              /    \                          /    \   
//                           [26]    [15]               --->  [10]    [15] 
//                          /   \    /   \                   /   \    /   \
//                       [19]  [14] [6]  [13]             [19]  [14] [6]  [13]
//                       /                                /
//                    [1]                               [1]  
                
//                 */
//                // 그리고 검사 위치를 변경
//                now/*0*/ = next/*1*/;

//            }

//            return ret;
//        }
//        public int Count()
//        {
//            return _heap.Count;
//        }
//    }

//    class Program
//    {
//        static void Main()
//        {
//            PriorityQueue q = new PriorityQueue();
//            q.Push(20);
//            q.Push(10);
//            q.Push(30);
//            q.Push(90);
//            q.Push(40);

//            while(q.Count() > 0)
//            {
//                Console.WriteLine(q.Pop());
//            }
//        }
//    }
//}
